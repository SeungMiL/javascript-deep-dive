내가 공부해서 이해한걸 정리해 보자
# 모던 자바스크립트 딥다이브 정리

### 1.1 변수는 왜 필요한가?

컴퓨터는 메모리를 통해 기억한다. 근데 그 메모리라는게 데이터를 저장할 수 있는 메모리 셀의 집합체이다.

그 셀은 메모리 주소를 갖는데 이 메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류를 발생시킬 가능성이 높은 매우 위험한 일이라고 한다. 그리고 그 메모리 주소를 아는것도 쉬워 보이지 않는다.

그래서 똑똑한 인간들은 메모리에 저장 하고 그 저장된 값을 읽어 들여 자기들 입맛대로 놀기 위해 만들어낸걸 우리는 **변수**라 하기로 했다.

책에서는 더 쉽게 **값의 위치를 가리키는 상징적인 이름** 이라고 멋있게 설명해 놓았다.

---

### 변수에 값을 저장하는 법과 여러개를 한번에 담는 방법을 알아보자.

```js
// 변수는 하나의 값을 저장하기 위한 수단이다.
var userId = 1;
var userName = 'Lee';

// 객체나 배열 같은 자료구조를 사용하면 여러 개의 값을 하나로 그룹화해서 하나의 값처럼 사용할 수 있다.
var user = { id: 1, name: 'Lee' };  -> 객체 그룹화

var users = [
  { id: 1, name: 'Lee' },
  { id: 2, name: 'Kim' }
];   -> 배열 그룹화
```


이처럼 변수에 값을 저장하는것을 할당이라 하며 이걸 읽어드리는 것을 참조라 한다.
변수는 사람이 이해할 수 있는 언어로 저장 시키는 것이므로 명확한 네이밍은 협업과 품질 향상에 도움을 준다.

---

### 1.2 식별자

변수 이름을 식별자 라고도 한다. 식별자는 어떤 값을 구별해서 식별할 수 있는 **고유한 이름** 을 말한다.

식별자는 값이 아니라 메모리 주소를 기억하고 있으며 메모리 주소에 붙인 이름이라고 할 수 있다.

변수만이 아니라 함수, 클래스 등의 이름도 모두 식별자다.
메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부른다.

---

### 1.3 변수 선언

변수를 사용하려면 반드시 선언이 필요하며 변수를 선언할 때는 
**var, let, const** 키워드를 사용한다.

```js
var score; // 변수 선언(변수 선언문)
```
이렇게 변수에 값을 할당하지않고 선언할 경우 **undefined** 라는 값으로 자동 할당 된다.

만약 선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생한다.

ReferenceError(참조 에러)는 식별자를 찾을 수 없을 때 발생하는 에러다.

---

### 1.4 변수 선언의 실행 시점과 변수 호이스팅

```js
console.log(score); // undefined

var score; // 변수 선언문
```

위 예제를 보았을때 순차적으로 실행되는 자바스크립트의 특성상 ReferenceError가 발생할 것처럼 보이나 undefined가 출력된다.
그 이유는 런타임이 아니라 그이전 단계에서 먼저 실행되기 때문이다.

자바스크립트는 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행하며 이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 것을 **변수 호이스팅**이라 한다.

※ 변수 뿐이 아니라 var, let, const, function, function*, class 로 선언하는 모든 식별자(변수,함수,클래스 등) 호이스팅 됨.

---

### 1.5 값의 할당

변수 선언은 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.

```js
console.log(score); // undefined

var score;  // ① 변수 선언
score = 80; // ② 값의 할당

console.log(score); // 80
```


```js
console.log(score); // undefined

var score = 80;     // 변수 선언과 값의 할당

console.log(score); // 80
```

두개의 예제는 모두 동일하게 동작한다.

그럼 이런 경우엔 어떨까?

```js
console.log(score); // undefined

score = 80; // 값의 할당
var score;  // 변수 선언

console.log(score); // ??
```
위 예제는 값을 할당한 후 변수선언을 한 경우이다
이런 경우에는 마지막 `console.log(score);` 은 값의 할당보다
변수 선언이 늦게 나왔기에 undefined 가 나온다.

---

### 1.6 값의 재할당

```js
var score = 80; // 변수 선언과 값의 할당
score = 90;     // 값의 재할당
```
만약 예제와 같이 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 **상수**라 한다.

변수를 선언하고 값을 할당 후 다시 재할당을 했을때 불필요해진 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제 된다. 단, 메모리에서 언제 해제될지는 예측할 수 없다.

**※가비지 콜렉터**
* 할당한 메모리 공간을 주기적으로 검사하여 더이상 사용되지 않는 메모리를 해제하는 기능을 말한다.
* 더이상 사용되지 않는 메모리란 간단히 말하자면 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다 => 메모리 누수를 방지한다.

---

### 1.7 식별자 네이밍 규칙

4가지 유형의 네이밍 컨벤션이 자주 사용된다

```js
// 카멜 케이스 (camelCase)
var firstName;

// 스네이크 케이스 (snake_case)
var first_name;

// 파스칼 케이스 (PascalCase)
var FirstName;

// 헝가리언 케이스 (typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementById('myId'); // DOM 노드
var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
```

코드 전체의 가독성을 높이려면 카멜 케이스와 파스칼 케이스를 따르는 것이 유리하다.
